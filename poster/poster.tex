\documentclass[final,hyperref={pdfpagelabels=true}]{beamer}

\usepackage{TUINFPST}

\usepackage[backend=bibtex,sortcites=true]{biblatex}
\usepackage{comment}
\usepackage{lipsum}
\usepackage{listings}
\usepackage{ragged2e}
\usepackage{xspace}

\newcommand{\klsm}{$k$-LSM\xspace}

\title[Software Engineering \& Internet Computing]{%
  \klsm:\\[0.2\baselineskip]% TODO: PDF title displays '[0.2]'.
  A Relaxed Lock-Free Priority Queue
}
\author[gruber@par.tuwien.ac.at]{Jakob Gruber}
\institute[]{%
  Technische Universit{\"a}t Wien\\[0.25\baselineskip]
  Institut f{\"u}r Informationssysteme\\[0.25\baselineskip]
  Arbeitsbereich: Parallel Computing\\[0.25\baselineskip]
  Betreuer: Prof. Dr. Scient. Jesper Larsson Tr\"aff
}
\titlegraphic{\includegraphics[height=52mm]{parcomp_logo}}
\date[\today]{\today}
\subject{epilog}
\keywords{concurrency, algorithms, lock-free, relaxed, priority queue}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Display a grid to help align images 
%\beamertemplategridbackground[12.7mm]

% play around with the background colors
% \setbeamercolor{background canvas}{bg=yellow}

% use a background picture
% \usebackgroundtemplate{%
%   \includegraphics[width=\paperwidth]{logo_KBS_2_CMYK}
% }

% play around with block colors
\setbeamercolor{block body}{fg=black,bg=white}
\setbeamercolor{block title}{fg=white,bg=TuWienBlue}

\setbeamertemplate{block begin}{
  \begin{beamercolorbox}{block title}%
    \begin{tikzpicture}%
      \node[draw,rectangle,line width=3pt,rounded corners=0pt,inner sep=0pt]{%
        \begin{minipage}[c][2cm]{\linewidth}
          \centering\textbf{\insertblocktitle}
        \end{minipage}
      };
    \end{tikzpicture}%
  \end{beamercolorbox}
  \vspace*{1cm}
  \begin{beamercolorbox}{block body}%
}

\setbeamertemplate{block end}{
  \end{beamercolorbox}
  \vspace{2cm}
}

% for crop marks, uncomment the following line
\usepackage[cross,width=88truecm,height=123truecm,center]{crop}

\bibliography{bibliography.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\begin{frame}
\begin{columns}[t]
% ---------------------------------------------------------%
\begin{column}{.45\textwidth}
\begin{block}{Context}
\justifying
Priority queues are abstract data structures which store a set of key/value pairs
and allow efficient access to the item with the minimal (maximal) key.

Due to the recent trend towards multiprocessor computing, it is becoming ever
more vital to develop data structure designs which scale well to a large number
of threads.

However, priority queues with traditional semantics incur an inherent sequential
bottleneck since each concurrent deletion attempts to remove the same minimal (maximal)
item.
\end{block}

\begin{block}{Problem Statement}
\justifying
While some gains can be made by optimizing access to the minimal (maximal)
element, results have shown limited scalability.

However, recently another promising approach based on weakening of
semantic guarantees has been gaining in popularity. Contrary to traditional,
strict priority queues, relaxed priority queues allow deletions to
return one of several potential candidate items, thus eliminating the
bottleneck at the minimal (maximal) item.
\end{block}
\end{column}
% ---------------------------------------------------------%

% ---------------------------------------------------------%
\begin{column}{.45\textwidth}
\begin{block}{The \klsm}
\justifying
\end{block}

\begin{block}{Results}
\justifying
\end{block}

\begin{block}{References}
\printbibliography
\end{block}
\end{column}
% ---------------------------------------------------------%
\end{columns}

\end{frame}
\end{document}
