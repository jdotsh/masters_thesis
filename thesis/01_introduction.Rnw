\chapter{Introduction} \label{ch:introduction}

% Move to many cores, why do we need concurrent algorithms/data structures?

In the past decade, advancements in computer performance have been made mostly
through an increasing number of processors instead of higher clock speeds.
This development necessitates new approaches to data structures and algorithms
that take advantage of concurrent execution on multiple threads and processors.

% The priority queue - semantics and usage summary.

This paper focuses on the priority queue data structure, consisting of two operations
traditionally called \lstinline|insert| and \lstinline|delete_min|. \lstinline|insert|
places an item into the queue together with its priority, while \lstinline|delete_min|
removes and returns the highest priority item. Both of these operations are expected to have
a complexity of at most $O(\log n)$. Priority queues are used in a large variety
of situations such as shortest path algorithms and scheduling. % See liu2012lock for more.

% Concurrent priority queues - heaps, trees, skiplists.

Concurrent priority queues have been the subject of research since the 1980s
\cite{ayani1990lr,biswas1987simultaneous,das1996distributed,deo1992parallel,huang1991evaluation,
luchetti1993some,mans1998portable,olariu1991optimal,prasad1995parallel}.
While early efforts have focused mostly on parallelizing Heap structures
\cite{hunt1996efficient},
more recently priority queues based on \citeauthor{pugh1990skip}'s SkipLists
\cite{pugh1990skip} seem to show more potential \cite{shavit2000skiplist,
sundell2003fast,herlihy2012art,linden2013skiplist}. Current research has also begun to examine
relaxed data structures \cite{wimmer2013data,alistarhspraylist,rihani2014multiqueues} which trade
strictness of provided guarantees against improved scalability.

% Thesis structure.

In the following, we investigate the evolution of concurrent priority queues suitable for general use,
i.e. unbounded range queues based on widely available atomic primitives such as \ac{CAS}.
Chapter \ref{ch:sequential} provides an outline of sequential priority queues, with a focus
on designs which have also been relevant to concurrent algorithms.
Chapter \ref{ch:definitions} outlines basic concepts and definitions. In Chapter \ref{ch:strict},
we cover important concurrent priority queues with strict semantics, e.g.:
the \citeauthor{hunt1996efficient} queue as a representative of early heap-based queues using
fine-grained locking to avoid the bottleneck of a single global lock; lock-free SkipList-based
structures offering better disjoint-access parallelism; and a very recent design called the CBPQ \cite{cbpq}.
Chapter \ref{ch:relaxed} presents three novel relaxed priority queues: the SprayList \cite{alistarhspraylist},
Multiqueues \cite{rihani2014multiqueues}, and the \klsm \cite{wimmer2015lock}.
Finally, experimental results are shown and discussed in Chapter \ref{ch:evaluation},
and the thesis is concluded in Chapter \ref{ch:conclusion}.
