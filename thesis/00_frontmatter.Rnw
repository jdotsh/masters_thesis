\begin{acknowledgements*}
To Martin and Jesper --- without your enthusiasm, ideas, and support, this thesis
would not have been possible.
\end{acknowledgements*}

\begin{kurzfassung}
\todo{Ihr Text hier.}
\end{kurzfassung}

\begin{abstract}
Priority queues are abstract data structures which store a set of key/value pairs
and allow efficient access to the item with the minimal (maximal) key. Such queues are an important
element in various areas of computer science such as algorithmics (i.e. Dijkstra's shortest
path algorithm) and operating system (i.e. priority schedulers).

The recent trend towards multiprocessor computing requires new implementations of basic
data structures which are able to be used concurrently and scale well to a large number
of threads. In particular, lock-free structures promise superior scalability by avoiding
the use of blocking synchronization primitives.

Concurrent priority queues have been extensively researched over the past decades.
In recent years, most research within the field has focused on SkipList-based structures,
based mainly on the fact that they exhibit very high disjoint access parallelism, i.e.,
modifications on different elements access disjoint parts of the data structure.
Contention between threads and traffic through the cache-coherency protocol
is therefore reduced.

However, SkipLists have less than optimal cache locality since each node is
usually allocated dynamically, which in turn results in fairly low throughput
for SkipList-based designs. Furthermore, strict priority queues incur an inherent
bottleneck at the minimal (maximal) element.

The \klsm is a novel design which
addresses these issues by using arrays as backing data structures and the standard
merge algorithm as its central operation (for high cache locality); and by relaxing
semantic guarantees to allow the \lstinline|delete_min| operation to allow one
of the $(k + 1) \cdot P$ elements, where $P$ is the number of threads.

During the course of this thesis, we have implemented a standalone version of
the \klsm and explain its design and implementation in detail. We finally evaluate the
the \klsm against a collection of other state-of-the-art concurrent priority queues
using a set of throughput benchmarks.
\end{abstract}
