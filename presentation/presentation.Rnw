\documentclass[usenames,dvipsnames]{beamer}

\usepackage{acronym}
\usepackage[backend=bibtex]{biblatex}
\usepackage{booktabs}
\usepackage{comment}
\usepackage{default}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{nameref}
\usepackage{pgf}
\usepackage{subcaption}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{xspace}

\graphicspath{{figures/}}
\input{acronyms}
\bibliography{bibliography.bib}

\setbeamertemplate{bibliography item}{}

\lstset{
    language=C++,
    basicstyle=\ttfamily \small,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=none,
}

\usetikzlibrary{ arrows
               , automata
               , backgrounds
               , calc
               , chains
               , fit
               , mindmap
               , petri
               , shapes
               , topaths
               }

\newcommand{\klsm}{$k$-LSM\xspace}

\title{\klsm}
\subtitle{A Relaxed Lock-Free Priority Queue}
\author{Jakob Gruber}
\date{\today}

\begin{document}

\tikzstyle{box} =
    [ draw,
    , rectangle,
    , text centered,
    , minimum width = 5mm,
    , minimum height = 5mm,
    , font = \footnotesize,
    , fill = black!10
    ]

\tikzstyle{deleted_box} =
    [ draw,
    , rectangle,
    , text centered,
    , minimum width = 5mm,
    , minimum height = 5mm,
    , font = \footnotesize,
    , text = black!50
    ]

\tikzstyle{flag_true} =
    [ draw,
    , circle,
    , inner sep = 0mm,
    , text width = 0.75mm,
    , fill = black
    ]

\tikzstyle{flag_false} =
    [ draw,
    , circle,
    , inner sep = 0mm,
    , text width = 0.75mm,
    ]

\maketitle

\begin{comment}
In general:
* less background. Mention some examples, add CBPQ, but less detail and time.
  Candidates: linden, multiq, spraylist.
* more about klsm. Principles, ideas (show the merge figure), architecture,
  implementation.
* more benchmarks. Different benchmark types, possibly add discussion points to
  slides.
\end{comment}

% --------------------------------------------------------------------------------------------------
\section{Introduction} \label{sec:intro}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:intro}}
\framesubtitle{Contents}

\begin{itemize}
\item Background, terms, definitions.
\item Related work.
\item The \klsm: design and implementation.
\item Results.
\end{itemize}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}[fragile]{\nameref{sec:intro}}
\framesubtitle{Sequential priority queues}

\acp{PQ}:

\begin{itemize}
\item Standard abstract data structure.
\item Used widely in algorithmics, operating systems, task scheduling, etc.
\item Interface consists of two $O(\log n)$ operations:

\begin{lstlisting}
void insert(const K &key, const V &val);
bool delete_min(V &val);
\end{lstlisting}

\item Typical backing data structures: heaps \& search trees.
\end{itemize}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:intro}}
\framesubtitle{Sequential priority queues: Heaps}

\begin{figure}
\begin{minipage}[b]{.5\textwidth}
\centering
\begin{tikzpicture}[every node/.style = box]
\node (1) at (0, 0)    {$0$};
\node (2) at (5mm, 0)  {$2$};
\node (3) at (10mm, 0) {$1$};
\node (4) at (15mm, 0) {$4$};
\node (5) at (20mm, 0) {$6$};
\node (6) at (25mm, 0) {$5$};
\node (7) at (30mm, 0) {$3$};
\node (8) at (35mm, 0) {$7$};
\node (9) at (40mm, 0) {$8$};

\path[->, dashed, every node/.style= { font = \sffamily\small }]
(1) edge[bend right = 60] node [right] {} (2)
(1) edge[bend right = 60] node [right] {} (3)
(2) edge[bend left = 60] node [right] {} (4)
(2) edge[bend left = 60] node [right] {} (5)
(3) edge[bend right = 60] node [right] {} (6)
(3) edge[bend right = 60] node [right] {} (7)
(4) edge[bend left = 60] node [right] {} (8)
(4) edge[bend left = 60] node [right] {} (9);
\end{tikzpicture}
\subcaption{Heap-ordered array.}
\end{minipage}%
\begin{minipage}[b]{.5\textwidth}
\centering
\begin{tikzpicture}[
    ->,
    every node/.style = box,
    level distance = 10mm,
    level 1/.style = { sibling distance = 20mm },
    level 2/.style = { sibling distance = 10mm }]]
  \node {$0$}
    child { node {$2$}
      child { node {$4$}
        child { node {$7$} }
        child { node {$8$} } }
      child { node {$6$} } }
    child { node {$1$}
      child { node {$5$} }
      child { node {$3$} } };
\end{tikzpicture}
\subcaption{Heap-ordered binary tree.}
\end{minipage}
\label{fig:heap_structure}
\end{figure}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:intro}}
\framesubtitle{Concurrent priority queues}

\begin{itemize}
\item Why? In the past decade, processor clock speeds have remained the same, trend towards multiple cores.
\item New data structures required to take advantage of concurrent execution.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:intro}}
\framesubtitle{In this thesis}

The \klsm:

\begin{itemize}
\item Linearizable, lock-free, relaxed.
\item Standalone reimplementation using C++11.
\item Extensive evaluation against related structures on multiple machines.
\item Different benchmarks demonstrate behavioral changes.
\item Semantic quality benchmarks show results are within theoretical bounds.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{Concepts and Definitions}
\framesubtitle{Safety conditions: nothing bad has happened yet}

\begin{itemize}
\item \emph{Quiescent consistency}: In a period of quiescence, semantics equivalent to some sequential ordering
\item \emph{Linearizability}: Operations appear to take effect at a single point in time between method invocation
      and return, called the linearization point.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{Concepts and Definitions}
\framesubtitle{Safety conditions: nothing bad has happened yet}

\only<1>{
\begin{figure}
\centering
\begin{tikzpicture}[start chain,
    ->,
    every node/.style={font = \small},
    label/.style={rectangle,minimum size = 5mm}
    ]

    \begin{scope}[start chain = 1 going right]
        \node [on chain=1] (t1_start) {Thread A};
        \node [on chain=1, xshift = 70mm] (t1_end) {};
    \end{scope}

    \begin{scope}[start chain = 2 going right]
        \node [on chain=2, below = of t1_start, yshift = 7.5mm] (t2_start) {Thread B};
        \node [on chain=2, xshift = 70mm] (t2_end) {};
    \end{scope}

    \path[dashed, -stealth'] (t1_start) edge node [above] {} (t1_end);
    \path[dashed, -stealth'] (t2_start) edge node [above] {} (t2_end);

    \path[line width = 1mm, serif cm-serif cm, every node/.style= { font = \footnotesize }]
        ($(t2_start.east) + (05mm, 0)$) edge node [above] {\lstinline|insert(5)|}
        ($(t2_start.east) + (20mm, 0)$)
        ($(t2_start.east) + (30mm, 0)$) edge node [above] {\lstinline|delete_min(1)|}
        ($(t2_start.east) + (45mm, 0)$);

    \path[line width = 1mm, serif cm-serif cm, every node/.style= { font = \footnotesize }]
        ($(t1_start.east) + (55mm, 0)$) edge node [above] {\lstinline|insert(1)|}
        ($(t1_start.east) + (70mm, 0)$);
\end{tikzpicture}
\caption{Neither quiescently consistent nor linearizable.}
\end{figure}
}

\only<2>{
\begin{figure}
\centering
\begin{tikzpicture}[start chain,
    ->,
    every node/.style={font = \small},
    label/.style={rectangle,minimum size = 5mm}
    ]

    \begin{scope}[start chain = 1 going right]
        \node [on chain=1] (t1_start) {Thread A};
        \node [on chain=1, xshift = 70mm] (t1_end) {};
    \end{scope}

    \begin{scope}[start chain = 2 going right]
        \node [on chain=2, below = of t1_start, yshift = 7.5mm] (t2_start) {Thread B};
        \node [on chain=2, xshift = 70mm] (t2_end) {};
    \end{scope}

    \path[dashed, -stealth'] (t1_start) edge node [above] {} (t1_end);
    \path[dashed, -stealth'] (t2_start) edge node [above] {} (t2_end);

    \path[line width = 1mm, serif cm-serif cm, every node/.style= { font = \footnotesize }]
        ($(t2_start.east) + (10mm, 0)$) edge node [above] {\lstinline|delete_min(5)|}
        ($(t2_start.east) + (30mm, 0)$)
        ($(t2_start.east) + (40mm, 0)$) edge node [above] {\lstinline|insert(5)|}
        ($(t2_start.east) + (60mm, 0)$);

    \path[line width = 1mm, serif cm-serif cm, every node/.style= { font = \footnotesize }]
        ($(t1_start.east) + (25mm, 0)$) edge node [above] {\lstinline|insert(1)|}
        ($(t1_start.east) + (45mm, 0)$);
\end{tikzpicture}
\caption{Quiescently consistent, but not linearizable.}
\end{figure}
}

\only<3>{
\begin{figure}
\centering
\begin{tikzpicture}[start chain,
    ->,
    every node/.style={font = \small},
    label/.style={rectangle,minimum size = 5mm}
    ]

    \begin{scope}[start chain = 1 going right]
        \node [on chain=1] (t1_start) {Thread A};
        \node [on chain=1, xshift = 70mm] (t1_end) {};
    \end{scope}

    \begin{scope}[start chain = 2 going right]
        \node [on chain=2, below = of t1_start, yshift = 7.5mm] (t2_start) {Thread B};
        \node [on chain=2, xshift = 70mm] (t2_end) {};
    \end{scope}

    \path[dashed, -stealth'] (t1_start) edge node [above] {} (t1_end);
    \path[dashed, -stealth'] (t2_start) edge node [above] {} (t2_end);

    \path[line width = 1mm, serif cm-serif cm, every node/.style= { font = \footnotesize }]
        ($(t2_start.east) + (10mm, 0)$) edge node [above] {\lstinline|insert(5)|}
        ($(t2_start.east) + (30mm, 0)$)
        ($(t2_start.east) + (40mm, 0)$) edge node [above] {\lstinline|delete_min(1)|}
        ($(t2_start.east) + (60mm, 0)$);

    \path[line width = 1mm, serif cm-serif cm, every node/.style= { font = \footnotesize }]
        ($(t1_start.east) + (50mm, 0)$) edge node [above] {\lstinline|insert(1)|}
        ($(t1_start.east) + (70mm, 0)$);
\end{tikzpicture}
\caption{Quiescently consistent and linearizable.}
\end{figure}
}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{Concepts and Definitions}
\framesubtitle{Liveness conditions: something good eventually happens}

\begin{itemize}
\item \emph{Lock-freedom}: at least a single process makes progress at all times
\item \emph{Wait-freedom}: every process finishes in a bounded number of steps
\end{itemize}
\end{frame}
% TODO: Slide about relaxation.
% --------------------------------------------------------------------------------------------------
\begin{frame}[fragile]{Concepts and Definitions}
\framesubtitle{Miscellaneous}
% TODO: Cut this slide?
\begin{itemize}
\item Synchronization primitives:
    \begin{itemize}
    \item \ac{CAS}, \ac{FAA}, \ac{FAO}, \ac{TAS}
    \item \ac{DCAS}, \ac{DCSS}
    \end{itemize}
\end{itemize}

\begin{lstlisting}
bool CAS(T *ptr, T *expected, T value) {
  if (*ptr == *expected) {
    *ptr = value;
    return true;
  } else {
    *expected = *ptr;
    return false;
  }
}
\end{lstlisting}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Related Work} \label{sec:related}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:related}}
\begin{itemize}
\item Strict concurrent \acp{PQ}
    \begin{itemize}
    \item \citeauthor{hunt1996efficient}: Fine-grained locking heap.
    \item \citeauthor{shavit2000skiplist}: First SkipList-based \ac{PQ}.
    \item \citeauthor{sundell2003fast}: First lock-free \ac{PQ}.
    \item \citeauthor{linden2013skiplist}: Minimizes contention.
    \item \citeauthor{cbpq}: Novel (non-SkipList) concept, efficient.
    \end{itemize}

\item Relaxed concurrent \acp{PQ}
    \begin{itemize}
    \item \citeauthor{alistarhspraylist}: SprayList.
    \item \citeauthor{rihani2014multiqueues}: Multiqueues.
    \item \citeauthor{wimmer2013data}: k-\ac{LSM}.
    \end{itemize}

\item Others: Non-standard synchronization primitives, bounded range priorities

\end{itemize}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Strict Priority Queues} \label{sec:strict}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:strict}}
\framesubtitle{\citeauthor{linden2013skiplist}}

\begin{itemize}
\item Most efficient strict \ac{SL}-based \ac{PQ}, linearizable.
\item Concurrent strict \ac{PQ} performance limited by contention and \ac{CAS} failures in
      \lstinline|DeleteMin| \textrightarrow ~ Minimize \ac{CAS} calls.
\item Deleted nodes form prefix of \ac{SL}, deletion flag packed into \lstinline|next| pointer of
      \emph{previous} node prevents insertion \emph{before} deleted node.
\item Most \lstinline|DeleteMin| perform logical deletion (1 \ac{CAS}) only, physical deletion
      only once a bound is reached.
\item Improves upon best previous \acp{PQ} by up to factor 2.
\item \fullcite{linden2013skiplist}
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:strict}}
\framesubtitle{\citeauthor{linden2013skiplist}}

\begin{figure}
\includegraphics[width=\textwidth]{linden}
\caption{The \citeauthor{linden2013skiplist} \ac{PQ}. Concurrent \lstinline|Insert(3)| and
\lstinline|DeleteMin| operations. Top right: \lstinline|DeleteMin| succeeds first,
\lstinline|Insert(3)| \ac{CAS} fails. Bottom right: \lstinline|Insert(3)| succeeds first,
\lstinline|DeleteMin| returns 3. (Image source: \cite{linden2013skiplist})}
\end{figure}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Relaxed Priority Queues} \label{sec:relaxed}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:relaxed}}

\begin{itemize}
\item Strict \acp{PQ} have inherent bottleneck at minimal element.
\item Another approach is to relax semantics, i.e. instead of returning \emph{the} minimal element,
      return one of the $k$ minimal elements.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{alistarhspraylist}: SprayList}

\begin{figure}
\centering
\begin{tikzpicture}[
    ->,
    start chain,
    every node/.style={font = \small},
    item/.style= box,
    label/.style={rectangle,minimum size = 5mm}
    ]

    \node[box] (3a) at (0, 15mm) {}; \node[box] (3h) at (70mm, 15mm) {};

    \node[box] (2a) at (0, 10mm) {}; \node[box] (2c) at (20mm, 10mm) {};
    \node[box] (2e) at (40mm, 10mm) {}; \node[box] (2h) at (70mm, 10mm) {};

    \node[box] (1a) at (0, 5mm) {}; \node[box] (1c) at (20mm, 5mm) {};
    \node[box] (1d) at (30mm, 5mm) {}; \node[box] (1e) at (40mm, 5mm) {}; \node[box] (1f) at (50mm, 5mm) {};
    \node[box] (1h) at (70mm, 5mm) {};

    \node[box] (0a) at (0, 0) {}; \node[box] (0b) at (10mm, 0) {0}; \node[box] (0c) at (20mm, 0) {1};
    \node[box] (0d) at (30mm, 0) {2}; \node[box] (0e) at (40mm, 0) {3}; \node[box] (0f) at (50mm, 0) {4};
    \node[box] (0g) at (60mm, 0) {5}; \node[box] (0h) at (70mm, 0) {};

    {
    [start chain] \chainin(0a); \chainin(0b) [join]; \chainin(0c) [join]; \chainin(0d) [join]; \chainin(0e) [join]; \chainin(0f) [join]; \chainin(0g) [join]; \chainin(0h) [join];
    [start chain] \chainin(1a); \chainin(1c) [join]; \chainin(1d) [join]; \chainin(1e) [join]; \chainin(1f) [join]; \chainin(1h) [join];
    [start chain] \chainin(2a); \chainin(2c) [join]; \chainin(2e) [join]; \chainin(2h) [join];
    [start chain] \chainin(3a); \chainin(3h) [join];
    }

    \begin{scope}[on background layer]
        \draw[gray, thick, dashed] (6mm, -4mm) rectangle (34mm, 19mm);
    \end{scope}
\end{tikzpicture}
\caption{The SprayList is based on a lock-free SkipList. Deletions randomly pick
         one of the $O(P \log P)$ smallest items.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{alistarhspraylist}: SprayList}

\begin{itemize}
\item Relaxed \ac{SL}-based \ac{PQ}, safety properties unclear.
\item \lstinline|DeleteMin| returns one of the $O(P \log^3 P)$ elements.
\item Degrades to random-remove if the \ac{PQ} is small compared to thread count $P$ (for $P = 80$,
      $P \log^3 P \approx 7000$).
\item \lstinline|DeleteMin| performs random walk: starting at the list head on some level $l$,
      repeatedly follow a randomized number of \lstinline|next[l]| pointers, descend a randomized
      number of levels.
\item Each element within the walk has approximately equal probability of being returned.
\item \fullcite{alistarhspraylist}
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{rihani2014multiqueues}: Multiqueues}

\begin{figure}
\centering
\begin{tikzpicture}[start chain,
    ->,
    every node/.style={font = \small},
    label/.style={rectangle,minimum size = 5mm}]

    \begin{scope}[start chain = 1 going right, node distance = -0.15mm]
        \node [on chain=1, minimum width = 10mm] (ba0) {$q_0$};
        \node [on chain=1, minimum width = 10mm] (ba1) {$q_1$};
        \node [on chain=1, minimum width = 10mm] (ba2) {$q_2$};
        \node [on chain=1, minimum width = 10mm] (ba3) {$q_3$};
        \node [on chain=1, minimum width = 10mm] (ba4) {$q_4$};
        \node [on chain=1, minimum width = 10mm] (ba5) {$q_5$};
    \end{scope}

    \begin{scope}[start chain = 2 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba0, yshift = 3mm] (00) {0};
        \node[on chain, box] {2};
        \node[on chain, box] {1};
        \node[on chain, box] {4};
        \node[on chain, box] {6};
        \node[on chain, box] {5};
        \node[on chain, box] {3};
        \node[on chain, box] {7};
        \node[on chain, box] {8};
    \end{scope}

    \begin{scope}[start chain = 3 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba1, yshift = 3mm] (10) {3};
        \node[on chain, box] {5};
        \node[on chain, box] {4};
        \node[on chain, box] {7};
        \node[on chain, box] {8};
        \node[on chain, box] {5};
    \end{scope}

    \begin{scope}[start chain = 4 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba2, yshift = 3mm] (20) {9};
    \end{scope}

    \begin{scope}[start chain = 5 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba3, yshift = 3mm] (30) {1};
        \node[on chain, box] {6};
        \node[on chain, box] {9};
        \node[on chain, box] {7};
    \end{scope}

    \begin{scope}[start chain = 6 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba4, yshift = 3mm] (40) {2};
    \end{scope}

    \begin{scope}[start chain = 7 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba5, yshift = 3mm] (50) {1};
        \node[on chain, box] {3};
        \node[on chain, box] {2};
        \node[on chain, box] {3};
        \node[on chain, box] {4};
        \node[on chain, box] {5};
        \node[on chain, box] {2};
    \end{scope}

    \begin{scope}[on background layer]
        \draw[gray, thick, dashed] ($(00.south west) - (1.5mm, 1.5mm)$) rectangle
                                ($(50.north east) + (1.5mm, 1.5mm)$);
    \end{scope}
\end{tikzpicture}
\caption{Multiqueues are a collection of priority queues. Deletions remove the minimal
         item from a randomly selected queue.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{rihani2014multiqueues}: Multiqueues}

\begin{itemize}
\item Decentralized collection of priority queues (e.g., sequential heaps protected by locks).
\item No given semantic bounds.
\item Insertions into a random queue.
\item Deletions take minimal item from two random queues.
\item \fullcite{rihani2014multiqueues}

\end{itemize}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{\klsm} \label{sec:klsm}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\begin{itemize}
\item First relaxed linearizable \ac{PQ} by \citeauthor{wimmerphd}.
\item Composition of two designs: the \ac{SLSM}, and the distributed \ac{DLSM}.
\item \fullcite{wimmer2015lock}
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\begin{figure}[ht]
\centering
\begin{tikzpicture}[mindmap,
  level 1 concept/.append style={level distance = 90, sibling angle = 60},
  level 2 concept/.append style={level distance = 65, sibling angle = 45},
  every node/.append style={scale = 0.75}]

  \begin{scope}[mindmap, concept color = black!10]
    \node [concept] {\klsm}[clockwise from=-60]
      child {node [concept] (dlsm) {\ac{DLSM}}
        [clockwise from = 45]
        child {node [concept] {Thread-local}}
        child {node [concept] {Distributed}}
        child {node [concept] {Efficient}}
        child {node [concept] {Scalable}}
        child {node [concept] {Strict}}}
      child {node [concept] (slsm) {\ac{SLSM}}
        [clockwise from = -90]
        child {node [concept] {Shared}}
        child {node [concept] {Global}}
        child {node [concept] {Relaxed}}
        child {node [concept] {Global Bottleneck}}};
  \end{scope}
\end{tikzpicture}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\begin{itemize}
\item Based on the concept of \acp{LSM}.
\item Maintain items in a logarithmic number of sorted arrays.
\item Array merges are the central operation.
\item Both insertions and deletions are in $O(\log n)$.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{\ac{LSM} Insertions}

\only<1>{
\begin{figure}
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_00.tex}
\subcaption{The initial state with item 7 inserted as a new block.}
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_01.tex}
\subcaption{After the first merge.}
\end{minipage}
\caption{Insertion of a new element into the \ac{LSM}.}
\label{fig:lsm_insertion}
\end{figure}
}

\only<2>{
\begin{figure}
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_01.tex}
\subcaption{After the first merge.}
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_02.tex}
\subcaption{After the second merge.}
\end{minipage}
\caption{Insertion of a new element into the \ac{LSM}.}
\label{fig:lsm_insertion}
\end{figure}
}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: Motivation}
\begin{itemize}
\item Comparability: Previously only part of the \emph{Pheet} task-scheduling framework,
      no direct comparisons against related structures possible.
\item Use in practice: Simple integration for use in practice.
\item Maintainability: The reimplementation is easy to read, easy to understand, and
      composable.
\item Scientific reproducibility: Verifies performance
      claims by \citeauthor{wimmerphd}.
\item Further insight and improvements.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation}

% Note that beamer does not like \verb apparently.
\begin{figure}
\centering
    \begin{tikzpicture}[start chain,
        ->,
        every node/.style={font = \small},
        label/.style={rectangle,minimum size = 5mm}
      ]

        \begin{scope}[start chain = 1 going {below=of \tikzchainprevious.south},
                every on chain/.style = {anchor = north},
                node distance = -0.15mm]
            \node[on chain, box] (klsm) {\texttt{k\_lsm}};
            \node[on chain, yshift = -5mm] (abpt) {\texttt{aligned\_block\_ptr}};
            \node[on chain] (bpool) {\texttt{block\_pool}};
            \node[on chain] (italloc) {\texttt{item\_allocator}};
            \node[on chain] (bstorage) {\texttt{block\_storage}};
            \node[on chain] (mm) {\emph{\small Memory Management}};
            \node[on chain, box, yshift = -5mm] (block) {\texttt{block}};
            \node[on chain, box, yshift = -5mm] (item) {\texttt{item}};
        \end{scope}

        \node[box, left = of italloc] (dlsm) {\texttt{dist\_lsm}};
        \node[box, right = of italloc] (slsm) {\texttt{shared\_lsm}};

        \node[box, below = of slsm] (barray) {\texttt{block\_array}};
        \node[box, below = of barray] (bpivots) {\texttt{block\_pivots}};

        \begin{pgfonlayer}{background}
            \draw[box] ($(abpt.north west) - (2mm, 0)$) rectangle ($(mm.north east) + (1mm, 0)$);
        \end{pgfonlayer}

        \path[->, every node/.style= { font = \sffamily\small }]
            (klsm.west) edge[bend right = 30] node [right] {} (dlsm)
            (klsm.east) edge[bend left = 30] node [right] {} (slsm)
            (dlsm.east) edge[bend right = 10] node [right] {} (italloc.west)
            (dlsm.east) edge[bend right = 10] node [right] {} (bstorage.west)
            (slsm.west) edge[bend left = 10] node [right] {} (abpt.east)
            (slsm.west) edge[bend left = 10] node [right] {} (bpool.east)
            (slsm.west) edge[bend left = 10] node [right] {} (italloc.east)
            (slsm.south) edge node [right] {} (barray.north)
            (barray.west) edge[bend left = 10] node [right] {} (block.east)
            (barray.south) edge node [right] {} (bpivots.north)
            (dlsm.south) edge[bend right = 30] node [right] {} (block.west)
            (block.south) edge node [right] {} (item.north);
    \end{tikzpicture}
\caption{Overview of the \lstinline|k_lsm| class structure.}
\label{fig:klsm_structure}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: \ac{DLSM}}
\begin{itemize}
\item Thread-local \acp{LSM}.
\item Reads by all threads, writes only by owner.
\item When local \ac{LSM} is empty, copy another thread's \ac{LSM} (\lstinline|spy|).
\item Insertions atomically replace changed part of \ac{LSM}.
\item Deletions simply mark item as taken.
\end{itemize}
% TODO: Insertion figure? Item interface?
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: \ac{SLSM}}
\begin{itemize}
\item Global \ac{LSM} shared by all threads.
\item Thread-local copies of the global \ac{LSM}.
\item Mutations change the thread-local copy, then atomically replace the global
      \ac{LSM}.
\item Relaxation through so-called \emph{pivot} ranges.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: \ac{SLSM}}
\begin{figure}
\centering
\input{slsm_structure.tex}
\caption{Schematic block array structure containing blocks $b_i$ and pivot ranges $p_i$, $i \in [1, 4]$.
         Items shown in white have been deleted.}
\label{fig:lsm_insertion}
\end{figure}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Results} \label{sec:Results}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput}

\begin{itemize}
\item We present throughput, i.e. the number of operations performed per second.
\item Prefilled with $10^6$ elements.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Benchmarks}

\begin{itemize}
\item \emph{Uniform workload}: Each thread repeatedly chooses uniformly at random between
    \lstinline|Insert| and \lstinline|DeleteMin|.
\item \emph{Split workload}: Half of all threads insert only, the other half deletes.
\item \emph{Uniform key generation}: Keys for insertions are generated uniformly at random
        within the range of 32 bit integers.
\item \emph{Ascending key generation}: Small range which rises over time:
        $\text{key}_t \in [0, 512[ + t$. Similar to the classic Hold pattern.
\item \emph{Restricted key generation}: Restricted key range, e.g. 8-bit integers.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}[fragile]{\nameref{sec:Results}}
\framesubtitle{Throughput: Algorithms}

\begin{itemize}
\item \verb|globallock|: A \verb|std::priority_queue<T>|, protected by a single global lock as a baseline.
\item \verb|linden|: The lock-free, strict, SkipList-based priority queue \cite{linden2013skiplist}.
\item \verb|spray|: A relaxed, lock-free, SkipList-based priority queue \cite{alistarhspraylist}.
      Provided implementation crashes in most benchmarks.
\item \verb|multiq|: A simple, elegant recent relaxed concurrent priority queue
      design \cite{rihani2014multiqueues}.
\item \verb|klsm16, klsm128, ...|:
      The standalone \klsm
      reimplementation using a wide range of values for the
      relaxation parameter $k$. Linearizable, lock-free, and relaxed \cite{wimmer2015lock}.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Machines}

\begin{itemize}
\item \lstinline|mars|, an 80-core (8x10 cores) Intel Xeon
      E7-8850 @ 2 GHz and 1 TB of RAM. 32 KB L1, 256 KB L2, 24 MB L3 cache.
\item \lstinline|saturn|, a 48-core machine with 4 AMD Opteron 6168 processors
      with 12 cores each, clocked at 1.9 GHz. 125 GB RAM, 64 KB of L1, 512 KB of L2, and 5 MB of L3 cache.
\item \lstinline|ceres|, a 64-core SPARCv9-based machine with 4 processors
      of 16 cores each. Cores are clocked at 3.6 GHz and have 8-way hardware
      hyperthreading. 1 TB RAM, 16 KB of L1, 128 KB of L2,
      and 8 MB of L3 cache.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Uniform workload, uniform key generation}
<<echo = FALSE>>=
\SweaveInput{pqplot.Rnw}

filter_results <- function(filename) {
    df <- read.csv(filename)
    colnames(df) <- c("kernel", "p", "throughput")
    df$throughput <- df$throughput/1E6

    return (df[df$kernel %in% c("klsm128", "klsm256", "klsm4096", "linden", "multiq", "globallock"), ])
}
@

\only<1>{
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_uni_uni")
@
\end{center}
\caption{\lstinline|mars|}
\end{figure}
}

\only<2>{
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results("results/20160203_saturn_uni_uni"))
@
\end{center}
\caption{\lstinline|saturn|}
\end{figure}
}

\only<3>{
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results("results/20160203_ceres_uni_uni"))
@
\end{center}
\caption{\lstinline|ceres|}
\end{figure}
}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Uniform workload, ascending keygeneration}
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_uni_asc")
@
\end{center}
\caption{\lstinline|mars|.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Split workload, uniform key generation}
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_spl_uni")
@
\end{center}
\caption{\lstinline|mars|.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Split workload, ascending keygeneration}
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_spl_asc")
@
\end{center}
\caption{\lstinline|mars|.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Quality}

\begin{itemize}
\item Are semantic guarantees fulfilled? And how good is the quality of results?
\item Determined by rank: for each \lstinline|delete_min|, if the removed item
is the $k$-smallest item at that time, it has rank $k$.
\item Reminder: The \klsm allows deletions to return up to rank $kP$ ($P$ is the number of threads).
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Quality}

\begin{table}[ht]
\footnotesize
\begin{center}
\begin{tabular}{lrrrrrr}
\toprule
& \multicolumn{2}{c}{20 threads} & \multicolumn{2}{c}{40 threads} & \multicolumn{2}{c}{80 threads} \\
\cmidrule(r){2-3}\cmidrule(r){4-5}\cmidrule(r){6-7}
& Mean & StdDev & Mean & StdDev & Mean & StdDev \\
\midrule
\lstinline|globallock| & 1.9 & 1.0 & 2.9 & 1.7 & 4.8 & 2.9 \\
\lstinline|klsm16|   & 20 & 15 & 23 & 20 & 15 & 9 \\
~(max)  & 320 & - & 640 & - & 1280 & - \\
\lstinline|klsm128|  & 33 & 31 & 55 & 46 & 430 & 294 \\
~(max)  & 2560 & - & 5120 & - & 10240 & - \\
\lstinline|klsm256|  & 42 & 42 & 71 & 61 & 750 & 828 \\
~(max)  & 5120 & - & 10240 & - & 20480 & - \\
\lstinline|klsm4096| & 297 & 496 & 625 & 1014 & 10353 & 12667 \\
~(max)  & 81920 & - & 163840 & - & 327680 & - \\
\lstinline|multiq|   & 984 & 2899 & 2252 & 7433 & 3787 & 12549 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Rank error for the uniform workload, uniform key generation benchmark
on \lstinline|mars|.}
\label{tbl:mars_uni_uni_q}
\end{table}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Conclusion} \label{sec:conclusion}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:conclusion}}
\begin{itemize}
\item The \klsm can have exceptional performance.
\item \ldots under the right conditions.
\item Although SkipList-based designs have dominated recent research, their performance is fairly low.
\item Multiqueues have lower peak performance, but have stable behavior in all experiments.

\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:conclusion}}
\centering
Questions?
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{References} \label{sec:references}
% --------------------------------------------------------------------------------------------------

\begin{frame}[allowframebreaks]{\nameref{sec:references}}
\printbibliography
\end{frame}

\end{document}
