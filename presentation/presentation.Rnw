\documentclass[usenames,dvipsnames]{beamer}

\usepackage{acronym}
\usepackage[backend=bibtex]{biblatex}
\usepackage{booktabs}
\usepackage{comment}
\usepackage{default}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{lmodern}
\usepackage{nameref}
\usepackage{pgf}
\usepackage{subcaption}
\usepackage{textcomp}
\usepackage{tikz}
\usepackage{xspace}

\graphicspath{{figures/}}
\input{acronyms}
\bibliography{bibliography.bib}

\setbeamertemplate{bibliography item}{}

\lstset{
    language=C++,
    basicstyle=\ttfamily \small,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=none,
}

\usetikzlibrary{ arrows
               , automata
               , backgrounds
               , calc
               , chains
               , fit
               , mindmap
               , petri
               , shapes
               , topaths
               }

\newcommand{\klsm}{$k$-LSM\xspace}

\title{\klsm}
\subtitle{A Relaxed Lock-Free Priority Queue}
\author{Jakob Gruber}
\date{\today}

\begin{document}

\tikzstyle{box} =
    [ draw,
    , rectangle,
    , text centered,
    , minimum width = 5mm,
    , minimum height = 5mm,
    , font = \footnotesize,
    , fill = black!10
    ]

\tikzstyle{deleted_box} =
    [ draw,
    , rectangle,
    , text centered,
    , minimum width = 5mm,
    , minimum height = 5mm,
    , font = \footnotesize,
    , text = black!50
    ]

\tikzstyle{flag_true} =
    [ draw,
    , circle,
    , inner sep = 0mm,
    , text width = 0.75mm,
    , fill = black
    ]

\tikzstyle{flag_false} =
    [ draw,
    , circle,
    , inner sep = 0mm,
    , text width = 0.75mm,
    ]

\maketitle

\begin{comment}
In general:
* less background. Mention some examples, add CBPQ, but less detail and time.
  Candidates: linden, multiq, spraylist.
* more about klsm. Principles, ideas (show the merge figure), architecture,
  implementation.
* more benchmarks. Different benchmark types, possibly add discussion points to
  slides.
  
* Way too much content. Possibly remove large parts of background and related work.
* Highlight more what I did.
\end{comment}

% --------------------------------------------------------------------------------------------------
\section{Introduction} \label{sec:intro}
% --------------------------------------------------------------------------------------------------

<<echo = FALSE>>=
library(RColorBrewer)
library(Rmisc)
library(ggplot2)
library(grid)
library(plyr)
library(scales)

pqplot <- function(csvfile) {
    # install.packages(c("Rmisc", "ggplot2", "plyr"))

    df <- read.csv(csvfile)
    colnames(df) <- c("kernel", "p", "throughput")

    df$throughput <- df$throughput/1E6

    pqplot_frame(df)
}

pqplot_frame <- function(df) {
    df2 <- ddply(df, .(kernel, p), summarize, mean = mean(throughput),
                 lower = CI(throughput)[[3]], upper = CI(throughput)[[1]])

    pq_colors <- brewer.pal(8, "Dark2")
    names(pq_colors) <- c("klsm128", "klsm256", "klsm4096", "linden", "multiq", "globallock", "spray")

    p <- ggplot(df2, aes(x = p, y = mean, color = kernel, shape = kernel)) +
                geom_line() +
                geom_point(size = 3) +
                geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.3) +
                scale_y_continuous(limits = c(0, NA), oob = squish) +
                scale_colour_manual(name = "kernel", values = pq_colors) +
                ylab("Throughput in Mops/s") +
                xlab("Number of threads") +
    # Themes
                theme_bw() +
                theme(axis.text = element_text(size = 16),
                      axis.title = element_text(size = 18),
                      legend.text = element_text(size = 16),
                      legend.title = element_text(size = 18),
                      legend.position = c(0, 1),
                      legend.justification = c(0, 1),
                      legend.background = element_rect(fill = alpha("black", 0)),
                      plot.margin = unit(c(0,0,0,0), "mm"))

    plot(p)
}

filter_results_to <- function(filename, algorithms) {
    df <- read.csv(filename)
    colnames(df) <- c("kernel", "p", "throughput")
    df$throughput <- df$throughput/1E6

    return (df[df$kernel %in% algorithms, ])
}

filter_results <- function(filename) {
    return (filter_results_to(filename, c("klsm128", "klsm256", "klsm4096", "linden", "multiq", "globallock")))
}

@

\begin{frame}{\nameref{sec:intro}}
\framesubtitle{The \klsm}

\begin{itemize}
\item Concurrent priority queue by Wimmer
\item \emph{Lock-free}: Progress condition. At least one thread makes progress at any time.
\item \emph{Linearizable}: Safety condition. Operations appear to take effect at one instant in time.
\item \emph{Relaxed}: Deletions may return one of $k$ smallest elements.
\end{itemize}
\end{frame}

\begin{frame}{\nameref{sec:intro}}
\framesubtitle{Motivation}

\begin{figure}[ht]
\begin{center}
\only<1>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results_to("results/20151112_mars_uni_uni", c("globallock")))
@
}
\only<2>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results_to("results/20151112_mars_uni_uni", c("globallock", "linden")))
@
}
\only<3>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results_to("results/20151112_mars_uni_uni", c("globallock", "linden", "multiq", "spray")))
@
}
\only<4>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results_to("results/20151112_mars_uni_uni", c("globallock", "linden", "multiq", "spray", "klsm256", "klsm4096")))
@
}
\end{center}
\caption{Throughput on \lstinline|mars|, uniform workload, uniform key generation.}
\end{figure}
  
\end{frame}

\begin{frame}{\nameref{sec:intro}}
\framesubtitle{Contents}

\begin{itemize}
\item Background.
\item Related work.
\item The \klsm: design and implementation.
\item Results.
\end{itemize}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}[fragile]{\nameref{sec:intro}}
\framesubtitle{Sequential priority queues}

\acp{PQ}:

\begin{itemize}
\item Standard abstract data structure.
\item Used widely in algorithmics, operating systems, task scheduling, etc.
\item Interface consists of two $O(\log n)$ operations:

\begin{lstlisting}
void insert(const K &key, const V &val);
bool delete_min(V &val);
\end{lstlisting}

\item Typical backing data structures: heaps \& search trees.
\end{itemize}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:intro}}
\framesubtitle{Concurrent priority queues}

\begin{itemize}
\item Why? In the past decade, processor clock speeds have remained the same, trend towards multiple cores.
\item New data structures required to take advantage of concurrent execution.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:intro}}
\framesubtitle{In this thesis}

Previously, \klsm only part of task-scheduling framework \emph{Pheet}.

\begin{itemize}
\item Standalone reimplementation (C++11, 4800 SLOC).
\item Extensive evaluation against related structures on multiple machines.
\item Different benchmarks demonstrate behavioral changes.
\item Semantic quality benchmarks show results are within theoretical bounds.
\end{itemize}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Related Work} \label{sec:related}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:related}}
\begin{itemize}
\item Strict concurrent \acp{PQ}
    \begin{itemize}
    \item \citeauthor{hunt1996efficient}: Fine-grained locking heap.
    \item \citeauthor{shavit2000skiplist}: First SkipList-based \ac{PQ}.
    \item \citeauthor{sundell2003fast}: First lock-free \ac{PQ}.
    \item \citeauthor{linden2013skiplist}: Minimizes contention.
    \item \citeauthor{cbpq}: Novel (non-SkipList) concept, efficient.
    \end{itemize}

\item Relaxed concurrent \acp{PQ}
    \begin{itemize}
    \item \citeauthor{alistarhspraylist}: SprayList.
    \item \citeauthor{rihani2014multiqueues}: Multiqueues.
    \item \citeauthor{wimmer2013data}: k-\ac{LSM}.
    \end{itemize}

\item Others: Non-standard synchronization primitives, bounded range priorities

\end{itemize}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Relaxed Priority Queues} \label{sec:relaxed}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:relaxed}}

\begin{itemize}
\item Strict \acp{PQ} have inherent bottleneck at minimal element.
\item Another approach is to relax semantics, i.e. instead of returning \emph{the} minimal element,
      return one of the $k$ minimal elements.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{alistarhspraylist}: SprayList}

\begin{figure}
\centering
\begin{tikzpicture}[
    ->,
    start chain,
    every node/.style={font = \small},
    item/.style= box,
    label/.style={rectangle,minimum size = 5mm}
    ]

    \node[box] (3a) at (0, 15mm) {}; \node[box] (3h) at (70mm, 15mm) {};

    \node[box] (2a) at (0, 10mm) {}; \node[box] (2c) at (20mm, 10mm) {};
    \node[box] (2e) at (40mm, 10mm) {}; \node[box] (2h) at (70mm, 10mm) {};

    \node[box] (1a) at (0, 5mm) {}; \node[box] (1c) at (20mm, 5mm) {};
    \node[box] (1d) at (30mm, 5mm) {}; \node[box] (1e) at (40mm, 5mm) {}; \node[box] (1f) at (50mm, 5mm) {};
    \node[box] (1h) at (70mm, 5mm) {};

    \node[box] (0a) at (0, 0) {}; \node[box] (0b) at (10mm, 0) {0}; \node[box] (0c) at (20mm, 0) {1};
    \node[box] (0d) at (30mm, 0) {2}; \node[box] (0e) at (40mm, 0) {3}; \node[box] (0f) at (50mm, 0) {4};
    \node[box] (0g) at (60mm, 0) {5}; \node[box] (0h) at (70mm, 0) {};

    {
    [start chain] \chainin(0a); \chainin(0b) [join]; \chainin(0c) [join]; \chainin(0d) [join]; \chainin(0e) [join]; \chainin(0f) [join]; \chainin(0g) [join]; \chainin(0h) [join];
    [start chain] \chainin(1a); \chainin(1c) [join]; \chainin(1d) [join]; \chainin(1e) [join]; \chainin(1f) [join]; \chainin(1h) [join];
    [start chain] \chainin(2a); \chainin(2c) [join]; \chainin(2e) [join]; \chainin(2h) [join];
    [start chain] \chainin(3a); \chainin(3h) [join];
    }

    \begin{scope}[on background layer]
        \draw[gray, thick, dashed] (6mm, -4mm) rectangle (34mm, 19mm);
    \end{scope}
\end{tikzpicture}
\caption{The SprayList is based on a lock-free SkipList. Deletions randomly pick
         one of the $O(P \log^3 P)$ smallest items.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{alistarhspraylist}: SprayList}

\begin{itemize}
\item Relaxed \ac{SL}-based \ac{PQ}, safety properties unclear.
\item \lstinline|DeleteMin| returns one of the $O(P \log^3 P)$ elements.
\item Degrades to random-remove if the \ac{PQ} is small compared to thread count $P$ (for $P = 80$,
      $P \log^3 P \approx 7000$).
\item \lstinline|DeleteMin| performs random walk: starting at the list head on some level $l$,
      repeatedly follow a randomized number of \lstinline|next[l]| pointers, descend a randomized
      number of levels.
\item Each element within the walk has approximately equal probability of being returned.
\item \fullcite{alistarhspraylist}
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{rihani2014multiqueues}: Multiqueues}

\begin{figure}
\centering
\begin{tikzpicture}[start chain,
    ->,
    every node/.style={font = \small},
    label/.style={rectangle,minimum size = 5mm}]

    \begin{scope}[start chain = 1 going right, node distance = -0.15mm]
        \node [on chain=1, minimum width = 10mm] (ba0) {$q_0$};
        \node [on chain=1, minimum width = 10mm] (ba1) {$q_1$};
        \node [on chain=1, minimum width = 10mm] (ba2) {$q_2$};
        \node [on chain=1, minimum width = 10mm] (ba3) {$q_3$};
        \node [on chain=1, minimum width = 10mm] (ba4) {$q_4$};
        \node [on chain=1, minimum width = 10mm] (ba5) {$q_5$};
    \end{scope}

    \begin{scope}[start chain = 2 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba0, yshift = 3mm] (00) {0};
        \node[on chain, box] {2};
        \node[on chain, box] {1};
        \node[on chain, box] {4};
        \node[on chain, box] {6};
        \node[on chain, box] {5};
        \node[on chain, box] {3};
        \node[on chain, box] {7};
        \node[on chain, box] {8};
    \end{scope}

    \begin{scope}[start chain = 3 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba1, yshift = 3mm] (10) {3};
        \node[on chain, box] {5};
        \node[on chain, box] {4};
        \node[on chain, box] {7};
        \node[on chain, box] {8};
        \node[on chain, box] {5};
    \end{scope}

    \begin{scope}[start chain = 4 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba2, yshift = 3mm] (20) {9};
    \end{scope}

    \begin{scope}[start chain = 5 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba3, yshift = 3mm] (30) {1};
        \node[on chain, box] {6};
        \node[on chain, box] {9};
        \node[on chain, box] {7};
    \end{scope}

    \begin{scope}[start chain = 6 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba4, yshift = 3mm] (40) {2};
    \end{scope}

    \begin{scope}[start chain = 7 going {above=of \tikzchainprevious.north},
            every on chain/.style={anchor=south},
            node distance = -0.15mm]
        \node[on chain, box, above = of ba5, yshift = 3mm] (50) {1};
        \node[on chain, box] {3};
        \node[on chain, box] {2};
        \node[on chain, box] {3};
        \node[on chain, box] {4};
        \node[on chain, box] {5};
        \node[on chain, box] {2};
    \end{scope}

    \begin{scope}[on background layer]
        \draw[gray, thick, dashed] ($(00.south west) - (1.5mm, 1.5mm)$) rectangle
                                ($(50.north east) + (1.5mm, 1.5mm)$);
    \end{scope}
\end{tikzpicture}
\caption{Multiqueues are a collection of priority queues. Deletions remove the minimal
         item from a randomly selected queue.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:relaxed}}
\framesubtitle{\citeauthor{rihani2014multiqueues}: Multiqueues}

\begin{itemize}
\item Decentralized collection of priority queues (e.g., sequential heaps protected by locks).
\item No given semantic bounds.
\item Insertions into a random queue.
\item Deletions take minimal item from two random queues.
\item \fullcite{rihani2014multiqueues}

\end{itemize}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{\klsm} \label{sec:klsm}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\begin{itemize}
\item First relaxed linearizable \ac{PQ} by \citeauthor{wimmerphd}.
\item Composition of two designs: the \ac{SLSM}, and the distributed \ac{DLSM}.
\item \fullcite{wimmer2015lock}
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\begin{figure}[ht]
\centering
\begin{tikzpicture}[mindmap,
  level 1 concept/.append style={level distance = 90, sibling angle = 60},
  level 2 concept/.append style={level distance = 65, sibling angle = 45},
  every node/.append style={scale = 0.75}]

  \begin{scope}[mindmap, concept color = black!10]
    \node [concept] {\klsm}[clockwise from=-60]
      child {node [concept] (dlsm) {\ac{DLSM}}
        [clockwise from = 45]
        child {node [concept] {Thread-local}}
        child {node [concept] {Distributed}}
        child {node [concept] {Efficient}}
        child {node [concept] {Scalable}}
        child {node [concept] {Strict}}}
      child {node [concept] (slsm) {\ac{SLSM}}
        [clockwise from = -90]
        child {node [concept] {Shared}}
        child {node [concept] {Global}}
        child {node [concept] {Relaxed}}
        child {node [concept] {Global Bottleneck}}};
  \end{scope}
\end{tikzpicture}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\begin{itemize}
\item Based on the concept of \acp{LSM}.
\item Maintain items in a logarithmic number of sorted arrays.
\item Array merges are the central operation.
\item Both insertions and deletions are in $O(\log n)$.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{\ac{LSM} Insertions}

\only<1>{
\begin{figure}
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_00.tex}
\subcaption{The initial state.}
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_01.tex}
\subcaption{Item 7 inserted as a new block.}
\end{minipage}
\caption{Insertion of a new element into the \ac{LSM}.}
\label{fig:lsm_insertion}
\end{figure}
}

\only<2>{
\begin{figure}
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_02.tex}
\subcaption{After the first merge.}
\end{minipage}%
\begin{minipage}[t]{.5\textwidth}
\centering
\input{klsm_insertion_03.tex}
\subcaption{After the second merge.}
\end{minipage}
\caption{Insertion of a new element into the \ac{LSM}.}
\label{fig:lsm_insertion}
\end{figure}
}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: Motivation}
\begin{itemize}
\item Comparability: Previously only part of the \emph{Pheet} task-scheduling framework,
      no direct comparisons against related structures possible.
\item Use in practice: Simple integration for use in practice.
\item Maintainability: The reimplementation is easy to read, easy to understand, and
      composable.
\item Scientific reproducibility: Verifies performance
      claims by \citeauthor{wimmerphd}.
\item Further insight and improvements.
\end{itemize}
\end{frame}
% TODO: Implementation stats? Time, SLOC, 
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation}

% Note that beamer does not like \verb apparently.
\begin{figure}
\centering
    \begin{tikzpicture}[start chain,
        ->,
        every node/.style={font = \small},
        label/.style={rectangle,minimum size = 5mm}
      ]

        \begin{scope}[start chain = 1 going {below=of \tikzchainprevious.south},
                every on chain/.style = {anchor = north},
                node distance = -0.15mm]
            \node[on chain, box] (klsm) {\texttt{k\_lsm}};
            \node[on chain, yshift = -5mm] (abpt) {\texttt{aligned\_block\_ptr}};
            \node[on chain] (bpool) {\texttt{block\_pool}};
            \node[on chain] (italloc) {\texttt{item\_allocator}};
            \node[on chain] (bstorage) {\texttt{block\_storage}};
            \node[on chain] (mm) {\emph{\small Memory Management}};
            \node[on chain, box, yshift = -5mm] (block) {\texttt{block}};
            \node[on chain, box, yshift = -5mm] (item) {\texttt{item}};
        \end{scope}

        \node[box, left = of italloc] (dlsm) {\texttt{dist\_lsm}};
        \node[box, right = of italloc] (slsm) {\texttt{shared\_lsm}};

        \node[box, below = of slsm] (barray) {\texttt{block\_array}};
        \node[box, below = of barray] (bpivots) {\texttt{block\_pivots}};

        \begin{pgfonlayer}{background}
            \draw[box] ($(abpt.north west) - (2mm, 0)$) rectangle ($(mm.north east) + (1mm, 0)$);
        \end{pgfonlayer}

        \path[->, every node/.style= { font = \sffamily\small }]
            (klsm.west) edge[bend right = 30] node [right] {} (dlsm)
            (klsm.east) edge[bend left = 30] node [right] {} (slsm)
            (dlsm.east) edge[bend right = 10] node [right] {} (italloc.west)
            (dlsm.east) edge[bend right = 10] node [right] {} (bstorage.west)
            (slsm.west) edge[bend left = 10] node [right] {} (abpt.east)
            (slsm.west) edge[bend left = 10] node [right] {} (bpool.east)
            (slsm.west) edge[bend left = 10] node [right] {} (italloc.east)
            (slsm.south) edge node [right] {} (barray.north)
            (barray.west) edge[bend left = 10] node [right] {} (block.east)
            (barray.south) edge node [right] {} (bpivots.north)
            (dlsm.south) edge[bend right = 30] node [right] {} (block.west)
            (block.south) edge node [right] {} (item.north);
    \end{tikzpicture}
\caption{Overview of the \lstinline|k_lsm| class structure.}
\label{fig:klsm_structure}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: \ac{DLSM}}
\begin{itemize}
\item Thread-local \acp{LSM}.
\item Reads by all threads, writes only by owner.
\item When local \ac{LSM} is empty, copy another thread's \ac{LSM} (\lstinline|spy|).
\item Insertions atomically replace changed part of \ac{LSM}.
\item Deletions simply mark item as taken.
\end{itemize}
% TODO: Insertion figure? Item interface?
% TODO: A figure showing how we arrive at kP bound.
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: \ac{SLSM}}
\begin{itemize}
\item Global \ac{LSM} shared by all threads.
\item Thread-local copies of the global \ac{LSM}.
\item Mutations change the thread-local copy, then atomically replace the global
      \ac{LSM}.
\item Relaxation through so-called \emph{pivot} ranges.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:klsm}}
\framesubtitle{Implementation: \ac{SLSM}}
\begin{figure}
\centering
\input{slsm_structure.tex}
\caption{Schematic block array structure containing blocks $b_i$ and pivot ranges $p_i$, $i \in [0, 3]$.
         Items shown in white have been deleted.}
\label{fig:lsm_insertion}
\end{figure}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Results} \label{sec:Results}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput}

% TODO: Do introduction of algorithms inline by changing algorithm colors to transparent?
% Or simply by introducing them one by one. Same with experiments, explain uniform/... as they
% come up.

\begin{itemize}
\item We present throughput, i.e. the number of operations performed per second.
\item Prefilled with $10^6$ elements.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Benchmarks}

\begin{itemize}
\item \emph{Uniform workload}: Each thread repeatedly chooses uniformly at random between
    \lstinline|Insert| and \lstinline|DeleteMin|.
\item \emph{Split workload}: Half of all threads insert only, the other half deletes.
\item \emph{Uniform key generation}: Keys for insertions are generated uniformly at random
        within the range of 32 bit integers.
\item \emph{Ascending key generation}: Small range which rises over time:
        $\text{key}_t \in [0, 512[ + t$. Similar to the classic Hold pattern.
\item \emph{Restricted key generation}: Restricted key range, e.g. 8-bit integers.
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Uniform workload, uniform key generation}

\begin{figure}[ht]
\centering
\only<1>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_uni_uni")
@
\caption{\lstinline|mars|}
}

\only<2>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results("results/20160203_saturn_uni_uni"))
@
\caption{\lstinline|saturn|}
}

\only<3>{
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot_frame(filter_results("results/20160203_ceres_uni_uni"))
@
\caption{\lstinline|ceres|}
}
\end{figure}

\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Uniform workload, ascending keygeneration}
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_uni_asc")
@
\end{center}
\caption{\lstinline|mars|.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Split workload, uniform key generation}
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_spl_uni")
@
\end{center}
\caption{\lstinline|mars|.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Throughput: Split workload, ascending keygeneration}
\begin{figure}[ht]
\begin{center}
<<fig = TRUE, width = 10, echo = FALSE>>=
pqplot("results/20151112_mars_spl_asc")
@
\end{center}
\caption{\lstinline|mars|.}
\end{figure}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Quality}

\begin{itemize}
\item Are semantic guarantees fulfilled? And how good is the quality of results?
\item Determined by rank: for each \lstinline|delete_min|, if the removed item
is the $k$-smallest item at that time, it has rank $k$.
\item Reminder: The \klsm allows deletions to return up to rank $kP$ ($P$ is the number of threads).
\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:Results}}
\framesubtitle{Quality}

\begin{table}[ht]
\footnotesize
\begin{center}
\begin{tabular}{lrrrrrr}
\toprule
& \multicolumn{2}{c}{20 threads} & \multicolumn{2}{c}{40 threads} & \multicolumn{2}{c}{80 threads} \\
\cmidrule(r){2-3}\cmidrule(r){4-5}\cmidrule(r){6-7}
& Mean & StdDev & Mean & StdDev & Mean & StdDev \\
\midrule
\lstinline|globallock| & 1.9 & 1.0 & 2.9 & 1.7 & 4.8 & 2.9 \\
\lstinline|klsm16|   & 20 & 15 & 23 & 20 & 15 & 9 \\
~(max)  & 320 & - & 640 & - & 1280 & - \\
\lstinline|klsm128|  & 33 & 31 & 55 & 46 & 430 & 294 \\
~(max)  & 2560 & - & 5120 & - & 10240 & - \\
\lstinline|klsm256|  & 42 & 42 & 71 & 61 & 750 & 828 \\
~(max)  & 5120 & - & 10240 & - & 20480 & - \\
\lstinline|klsm4096| & 297 & 496 & 625 & 1014 & 10353 & 12667 \\
~(max)  & 81920 & - & 163840 & - & 327680 & - \\
\lstinline|multiq|   & 984 & 2899 & 2252 & 7433 & 3787 & 12549 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Rank error for the uniform workload, uniform key generation benchmark
on \lstinline|mars|.}
\label{tbl:mars_uni_uni_q}
\end{table}
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{Conclusion} \label{sec:conclusion}
% --------------------------------------------------------------------------------------------------

\begin{frame}{\nameref{sec:conclusion}}
\begin{itemize}
\item Standalone reimplementation completed successfully.
\item The \klsm can have exceptional performance.
\item \ldots under the right conditions.
\item Although SkipList-based designs have dominated recent research, their performance is fairly low.
\item Multiqueues have lower peak performance, but have stable behavior in all experiments.

\end{itemize}
\end{frame}
% --------------------------------------------------------------------------------------------------
\begin{frame}{\nameref{sec:conclusion}}
\centering
Questions?
\end{frame}

% --------------------------------------------------------------------------------------------------
\section{References} \label{sec:references}
% --------------------------------------------------------------------------------------------------

\begin{frame}[allowframebreaks]{\nameref{sec:references}}
\printbibliography
\end{frame}

\end{document}
